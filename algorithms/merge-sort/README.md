# 📌 Merge Sort (병합 정렬)

병합 정렬은 **"분할 정복(Divide and Conquer)"** 전략을 사용하는 정렬 알고리즘입니다.  
배열을 계속 반으로 나눈 후, 정렬된 상태로 병합하여 정렬을 수행합니다.

## 🚀 동작 원리

1. **분할(Divide)**: 배열을 **절반씩 나누어** 더 이상 나눌 수 없을 때까지 재귀적으로 호출합니다.
2. **정복(Conquer)**: 나뉜 배열을 정렬하면서 **두 개의 정렬된 배열을 병합(merge)** 합니다.
3. **결합(Combine)**: 모든 배열이 정렬된 상태로 병합되면 최종적으로 정렬된 배열이 완성됩니다.

## ⏱️ 시간 복잡도

| 경우                    | 시간 복잡도    | 설명                                                               |
| ----------------------- | -------------- | ------------------------------------------------------------------ |
| **최선 (Best Case)**    | **O(n log n)** | 이미 정렬된 경우에도 배열을 나누고 병합하는 과정이 동일하게 수행됨 |
| **평균 (Average Case)** | **O(n log n)** | 입력 배열이 무작위 순서일 때도 동일한 단계로 정렬이 진행됨         |
| **최악 (Worst Case)**   | **O(n log n)** | 역순 정렬된 경우에도 다른 경우와 동일한 분할 및 병합 과정 수행     |

## ✅ 장점

✅ **일관된 O(n log n) 성능 보장**

- 최선, 평균, 최악의 경우 모두 **O(n log n)** 으로 일정한 성능을 유지합니다.
- 퀵 정렬(Quick Sort)의 최악 시간 복잡도 O(n²)과 비교하면 안정적인 성능을 제공합니다.

✅ **안정 정렬 (Stable Sort)**

- 동일한 값의 순서를 유지하므로, 정렬 후에도 원래의 상대적 순서가 보장됩니다.
- 예를 들어, 데이터베이스에서 특정 열을 기준으로 정렬할 때 유용합니다.

✅ **분할 정복(Divide & Conquer) 알고리즘 사용**

- 문제를 작은 부분으로 나누어 처리하므로 이해하기 쉽고, 재귀적으로 구현이 가능합니다.

✅ **외부 정렬(External Sorting)에 적합**

- 연속된 메모리에 데이터를 로드할 필요가 없고, 파일과 같은 큰 데이터 정렬에도 활용할 수 있습니다.

## ❌ 단점

❌ **추가적인 메모리 공간 필요 (O(n))**

- 병합 과정에서 새로운 배열을 만들어야 하므로 **O(n)** 크기의 추가적인 공간이 필요합니다.
- 이는 퀵 정렬(Quick Sort)처럼 **제자리 정렬(in-place sorting)** 이 가능한 알고리즘보다 비효율적일 수 있습니다.

❌ **작은 데이터에서는 비효율적**

- 작은 배열의 경우, 삽입 정렬(Insertion Sort)보다 느릴 수 있습니다.
- 함수 호출과 병합 과정에서 추가적인 연산이 필요하기 때문입니다.
