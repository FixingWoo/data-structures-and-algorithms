# 📌 삽입 정렬 (Insertion Sort)

삽입 정렬은 현재 요소를 적절한 위치에 삽입하는 방식으로 정렬하는 알고리즘입니다.

## 🚀 동작 원리

1. 배열의 **첫 번째 요소**부터 **마지막 요소까지 반복하면서** 최소값을 찾습니다.
2. 가장 작은 값을 현재 위치와 교환하여 정렬을 진행합니다.
3. 위 과정을 배열의 크기만큼 반복하여 **완전히 정렬**합니다.

## 🎯 예제 실행 과정

### 입력: `[2,1,9,76,4]`

---

### 🔹 첫 번째 반복 (`i = 1`)

- `currentVal = 1`
- `2 > 1` → `2`를 오른쪽으로 이동 → `[2,2,9,76,4]`
- `1`을 제자리(`arr[0]`)에 삽입 → **`[1,2,9,76,4]`**

---

### 🔹 두 번째 반복 (`i = 2`)

- `currentVal = 9`
- `9`은 이미 정렬된 부분에서 올바른 위치에 있음 → **변경 없음**

---

### 🔹 세 번째 반복 (`i = 3`)

- `currentVal = 76`
- `76`도 이미 정렬된 부분에서 올바른 위치에 있음 → **변경 없음**

---

### 🔹 네 번째 반복 (`i = 4`)

- `currentVal = 4`
- `76 > 4` → `76`을 오른쪽으로 이동 → `[1,2,9,76,76]`
- `9 > 4` → `9`를 오른쪽으로 이동 → `[1,2,9,9,76]`
- `4`를 제자리(`arr[2]`)에 삽입 → **`[1,2,4,9,76]`**

---

### ✅ 최종 결과

**`[1,2,4,9,76]`**

## ⏱️ 시간 복잡도

| 경우                    | 시간 복잡도 | 설명                                                      |
| ----------------------- | ----------- | --------------------------------------------------------- |
| **최선 (Best Case)**    | **O(n)**    | 이미 정렬된 경우, 한 번씩만 비교 (비교 O(n), 이동 O(1))   |
| **평균 (Average Case)** | **O(n²)**   | 요소마다 적절한 위치를 찾기 위해 비교와 이동 발생         |
| **최악 (Worst Case)**   | **O(n²)**   | 역순 정렬된 경우, 모든 요소를 이동해야 하므로 최악의 성능 |

## ✅ 장점

✅ **거의 정렬된 데이터에 유리함**

✅ **같은 값을 가진 요소들의 순서가 유지됨**

✅ **추가적인 메모리 필요 없음 (제자리 정렬, in-place sort)**

## ❌ 단점

❌ **최악의 경우 성능이 O(n²)으로 매우 비효율적**

❌ **큰 데이터셋에서 성능이 좋지 않음**
