# 📌 큐 (Queue)

큐(Queue)는 **FIFO(First In, First Out, 선입선출)** 구조를 따르는 자료구조입니다.  
즉, 먼저 들어온 요소가 먼저 제거됩니다.

## 🚀 기능

- `enqueue(value)`: 값을 큐의 뒤(rear)에 추가
- `dequeue()`: 큐의 앞(front)에서 값을 제거하고 반환
- `peek()`: 큐의 앞(front) 요소를 반환
- `isEmpty()`: 큐가 비어있는지 확인
- `getSize()`: 현재 큐에 저장된 요소 개수를 반환

## 🕒 시간 복잡도

| 연산        | 시간 복잡도 | 설명                                                              |
| ----------- | ----------- | ----------------------------------------------------------------- |
| `enqueue()` | **O(1)**    | 새로운 요소를 큐의 끝(rear)에 추가하는 연산은 **상수 시간** 소요. |
| `dequeue()` | **O(1)**    | 큐의 앞(front) 요소를 제거하는 연산은 **상수 시간** 소요.         |
| `peek()`    | **O(1)**    | 큐의 맨 앞 요소를 확인하는 연산은 **상수 시간** 소요.             |
| `isEmpty()` | **O(1)**    | 큐가 비었는지 확인하는 연산은 **상수 시간** 소요.                 |

> **큐의 모든 연산은 O(1)로 빠르게 수행 가능**

## ✅ 장점

✅ **빠른 연산 속도**

- `enqueue`, `dequeue`, `peek` 연산이 **O(1)** 로 매우 빠름
- **FIFO 구조**로 인해 데이터가 **순서대로 처리됨**

✅ **메모리 효율성**

- 필요할 때만 데이터를 추가/삭제할 수 있음
- 연결 리스트 기반 큐는 **동적 메모리 할당**이 가능하여 크기 조절이 유연함

✅ **순차적 데이터 처리에 적합**

- **운영체제의 작업 스케줄링**, **네트워크 패킷 전송**, **BFS 탐색** 등에서 유용함

## ❌ 단점

❌ **무작위 접근 불가능**

- 특정 위치(index)의 요소를 바로 조회할 수 없음
- 항상 **맨 앞(front)에서만 데이터 접근 가능**
- 원하는 데이터를 찾으려면 모든 요소를 제거해야 할 수도 있음

❌ **고정 크기 문제 (배열 기반 큐)**

- 배열을 기반으로 한 큐의 경우 **초기 크기 설정**이 필요함
- 크기를 초과하면 **새로운 배열을 할당**해야 하는 경우가 발생하여 성능 저하 가능

❌ **연결 리스트 기반 큐는 추가 메모리 필요**

- 연결 리스트 기반 큐의 경우 `next` 포인터를 저장해야 하므로 **추가적인 메모리 공간 필요**
