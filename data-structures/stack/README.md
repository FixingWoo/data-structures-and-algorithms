# 📌 스택 (Stack)

스택(Stack)은 **LIFO(Last In, First Out, 후입선출)** 구조를 따르는 자료구조입니다.
즉, 가장 나중에 추가된 요소가 가장 먼저 제거됩니다.

## 🚀 기능

- `push(value)`: 값을 스택에 추가합니다.
- `pop()`: 스택에서 값을 제거하고 반환합니다.
- `peek()`: 스택의 최상단 요소를 반환합니다.
- `isEmpty()`: 스택이 비어있는지 확인합니다.
- `getSize()`: 현재 스택에 저장된 요소 개수를 반환합니다.

## 🕒 시간 복잡도

| 연산        | 시간 복잡도 | 설명                                                               |
| ----------- | ----------- | ------------------------------------------------------------------ |
| `push()`    | **O(1)**    | 새 노드를 스택의 맨 위에 추가하는 연산은 **상수 시간**이 걸립니다. |
| `pop()`     | **O(1)**    | 스택의 맨 위 노드를 제거하는 연산은 **상수 시간**이 걸립니다.      |
| `peek()`    | **O(1)**    | 스택의 맨 위 노드를 확인하는 연산은 **상수 시간**이 걸립니다.      |
| `isEmpty()` | **O(1)**    | 스택이 비었는지 확인하는 연산은 **상수 시간**이 걸립니다.          |

> **스택의 모든 연산은 O(1)로 빠르게 수행 가능합니다**

## ✅ 장점

✅ **빠른 연산 속도**

- `push`, `pop`, `peek` 연산이 **O(1)** 로 매우 빠름
- 배열과 달리 중간 삽입/삭제 연산이 필요 없음

✅ **메모리 효율성**

- 필요한 데이터만 저장하여 메모리를 절약할 수 있음
- 연결 리스트 기반 스택은 동적 메모리 할당이 가능하여 크기를 유동적으로 조절 가능

✅ **간결한 구현**

- 개념이 직관적이며, 구현이 간단함

## ❌ 단점

❌ **무작위 접근 불가능**

- 특정 위치(index)에 있는 데이터를 바로 조회할 수 없음
- 항상 **맨 위(top)에서만 데이터 접근 가능**
- 원하는 데이터를 찾기 위해 모든 데이터를 제거해야 할 수도 있음

❌ **고정 크기 문제 (배열 기반 스택)**

- 배열을 기반으로 한 스택의 경우 **초기 크기 설정**이 필요함
- 크기를 초과하면 **새로운 배열을 할당**해야 하는 경우가 발생하여 성능 저하 가능

❌ **연결 리스트 기반 스택은 추가 메모리 필요**

- 연결 리스트 기반 스택의 경우 `next` 포인터를 저장해야 하므로 **추가적인 메모리 공간 필요**
