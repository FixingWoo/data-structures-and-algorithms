# 📌 이중 연결 리스트 (Doubly Linked List)

이중 연결 리스트는 각 요소가 **값(value)**, **이전 노드를 가리키는 포인터(prev pointer)**, **다음 노드를 가리키는 포인터(next pointer)** 를 갖는 노드들로 구성된 **선형 자료구조**입니다.  
단일 연결 리스트(Singly Linked List)와 달리 **이전 노드로도 이동할 수 있어 탐색 및 삭제가 효율적**입니다.

## 🚀 기능

- `push(value)`: 리스트의 끝에 새로운 노드를 추가합니다.
- `pop()`: 리스트의 마지막 노드를 삭제합니다.
- `shift()`: 리스트의 첫 번째 노드를 삭제합니다.
- `unshift(value)`: 리스트의 맨 앞에 새로운 노드를 추가합니다.
- `get(index)`: 특정 인덱스의 노드를 반환합니다.
- `set(index, value)`: 특정 인덱스의 값을 설정합니다.
- `insert(index, value)`: 지정한 인덱스에 값을 삽입합니다.
- `remove(index)`: 특정 인덱스의 노드를 삭제합니다.

## ⏱️ 시간 복잡도

| 연산                   | 시간 복잡도 | 설명                                                                 |
| ---------------------- | ----------- | -------------------------------------------------------------------- |
| `push(value)`          | O(1)        | 리스트의 끝에 노드를 추가하는 작업은 **상수 시간**이 걸립니다.       |
| `pop()`                | O(1)        | 리스트의 마지막 노드를 삭제하는 작업도 **상수 시간**이 걸립니다.     |
| `shift()`              | O(1)        | 첫 번째 노드를 삭제하는 작업은 **상수 시간**이 걸립니다.             |
| `unshift(value)`       | O(1)        | 첫 번째 노드에 새로운 값을 추가하는 작업은 **상수 시간**이 걸립니다. |
| `get(index)`           | O(n)        | 특정 인덱스를 찾기 위해 리스트를 **순차적으로 탐색**해야 합니다.     |
| `set(index, value)`    | O(n)        | 특정 인덱스를 찾아 값을 수정해야 하므로 O(n)입니다.                  |
| `insert(index, value)` | O(n)        | 삽입 위치까지 탐색해야 하므로 O(n)입니다.                            |
| `remove(index)`        | O(n)        | 삭제할 위치까지 탐색한 후 삭제하는 작업은 O(n)입니다.                |

## ✅ 장점

✅ **양방향 탐색 가능**

- `prev` 포인터를 활용해 **앞뒤 방향 모두 이동 가능**
- 특정 노드를 찾을 때 **더 빠르게 탐색 가능** (`get(index)` 연산 시 유리)

✅ **노드 삭제 및 삽입이 용이**

- 단일 연결 리스트는 노드를 삭제할 때 **이전 노드의 참조를 유지해야 하지만**,  
  이중 연결 리스트는 **`prev` 포인터 덕분에 이전 노드 접근이 쉬워 삭제가 더 효율적**

✅ **유연한 리스트 구조**

- 리스트의 **양 끝(head, tail)에서 빠르게 추가/삭제 가능**
- **큐(Queue)와 덱(Deque) 등의 자료구조**에 적합

## ❌ 단점

❌ **메모리 사용량 증가**

- 각 노드가 **추가적인 `prev` 포인터를 저장해야 하므로** 단일 연결 리스트보다 **메모리를 더 많이 사용**

❌ **구현이 더 복잡함**

- `prev`와 `next`를 모두 관리해야 하므로 **삽입, 삭제 연산 구현이 단일 연결 리스트보다 복잡**
- 리스트를 조작할 때 **더 많은 코드가 필요**

❌ **배열(Array)에 비해 랜덤 접근이 비효율적**

- 인덱스로 직접 접근이 가능한 배열과 달리, 특정 인덱스에 접근하려면 **O(n)의 탐색 시간이 필요**

## 📌 단일 연결 리스트(Singly Linked List)와의 비교

| 비교 항목           | 단일 연결 리스트 (Singly) | 이중 연결 리스트 (Doubly)    |
| ------------------- | ------------------------- | ---------------------------- |
| **메모리 사용량**   | 적음                      | `prev` 포인터로 인해 더 많음 |
| **삭제 연산 효율**  | O(n)                      | O(1) (이전 노드 접근 가능)   |
| **탐색 속도**       | 느림 (한 방향 탐색)       | 빠름 (양방향 탐색 가능)      |
| **구현 난이도**     | 쉬움                      | 복잡함                       |
| **뒤에서부터 접근** | ❌ 불가능                 | ✅ 가능                      |

---
