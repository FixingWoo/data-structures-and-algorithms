# 단일 연결 리스트 (Singly Linked List)

단일 연결 리스트는 각 요소가 **값(value)**과 **다음 노드를 가리키는 포인터(next pointer)**를 갖는 노드로 구성된 선형 자료구조입니다. 각 노드는 리스트의 앞에서 뒤로 연결되어 있으며, **순차적 데이터 저장 및 접근**을 제공합니다.

## 🚀 기능

- **push(value)**: 리스트의 끝에 새로운 노드를 추가합니다.
- **pop()**: 리스트의 마지막 노드를 삭제합니다.
- **shift()**: 리스트의 첫 번째 노드를 삭제합니다.
- **unshift(value)**: 리스트의 맨 앞에 새로운 노드를 추가합니다.
- **get(index)**: 특정 인덱스의 노드를 반환합니다.
- **set(index, value)**: 특정 인덱스에 값을 설정합니다.
- **insert(index, value)**: 지정한 인덱스에 값을 삽입합니다.
- **remove(index)**: 특정 인덱스의 노드를 삭제합니다.
- **reverse()**: 리스트를 뒤집습니다.

## ⏱️ 시간 복잡도

- **push(value)**: `O(1)` - 끝에 노드를 추가하는 작업은 상수 시간이 걸립니다.
- **pop()**: `O(n)` - 끝 노드를 찾기 위해 처음부터 끝까지 탐색해야 하므로 시간 복잡도는 `O(n)`입니다.
- **shift()**: `O(1)` - 첫 번째 노드를 삭제하는 작업은 상수 시간이 걸립니다.
- **unshift(value)**: `O(1)` - 첫 번째 노드에 값을 추가하는 작업은 상수 시간이 걸립니다.
- **get(index)**: `O(n)` - 특정 인덱스를 찾기 위해 리스트를 처음부터 순차적으로 탐색해야 합니다.
- **set(index, value)**: `O(n)` - 특정 인덱스에 접근한 후 값을 수정하는 작업은 탐색 시간이 걸리므로 `O(n)`입니다.
- **insert(index, value)**: `O(n)` - 삽입 위치까지 탐색해야 하므로 `O(n)`입니다.
- **remove(index)**: `O(n)` - 삭제할 위치까지 탐색한 후 삭제하는 작업은 `O(n)`입니다.
- **reverse()**: `O(n)` - 리스트를 뒤집기 위해 한 번의 순차적 탐색이 필요합니다.

## 🚀 장점

- **동적 메모리 할당**: 크기가 동적으로 변화할 수 있으며, 미리 메모리를 할당할 필요가 없습니다.
- **삽입/삭제 효율성**: 특정 위치에 데이터 삽입 및 삭제가 용이합니다.

## ⚠️ 단점

- **순차적 접근**: 특정 인덱스에 접근하라면 리스트를 순차적으로 탐색해야 하므로, 탐색 속도가 느릴 수 있습니다.
- **메모리 추가 소비**: 각 노드는 값 외에도 next 포인터를 저장해야 하므로 추가 메모리 공간이 필요합니다.
